{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-4d940a6d79cb61b9374adbb6aa2e39924f43b783",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/vengence.sol": "project/contracts/vengence.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/ierc1155.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\ninterface IERC1155 {\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n\n\ninterface IERC1155Receiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC1155MetadataURI {\n    function uri(uint256 id) external view returns (string memory);\n}"
      },
      "project/contracts/lib/events.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nlibrary Events {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n    event URI(string value, uint256 indexed id);\n}\n"
      },
      "project/contracts/vengence.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {IERC1155, IERC1155Receiver} from \"./interfaces/ierc1155.sol\";\nimport {Events} from \"./lib/events.sol\";\n\ncontract Vengence is IERC1155 {\n\n    uint256 constant public INDEXOF_GOLD = 0;\n    uint256 constant public INDEXOF_SILVER = 1;\n    uint256 constant public INDEXOF_BATMAN = 2;\n\n\n\n    mapping(uint256 => mapping(address => uint256)) internal _balances;\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n    mapping(uint => uint) public totalSupplyOfTokens;\n\n    mapping(uint256 => string) private _tokenURIs;\n\n    address public admin;\n\n\n\n\n    modifier onlyAdmin{\n        require(msg.sender == admin, \"youre not an admin\");\n        _;\n    }\n    constructor(){\n        admin = msg.sender;\n    }\n\n\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256 myBalance_){\n        myBalance_ = _balances[_id][_owner]; \n    }\n\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory balanceOfOwners_){\n\n         require(_owners.length == _ids.length, \"Account to ids mismatch, Please have an equal number of both\");\n\n        uint256[] memory _batchBalance = new uint256[](_owners.length);\n\n        for(uint256 i = 0; i < _owners.length; ++i){\n            require(_owners[i] != address(0), \"Invalid owner address\");\n\n            _batchBalance[i] = _balances[_ids[i]][_owners[i]];\n        }\n        balanceOfOwners_ = _batchBalance;\n    }\n\n\n    function setApprovalForAll(address _operator, bool _approved) external{\n        _operatorApprovals[msg.sender][_operator] = _approved;\n\n        emit Events.ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool){\n        return _operatorApprovals[_owner][_operator];\n    }\n\n\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external{\n        \n        require(_to != address(0), \"The receiving account is an address zero:: cannot transfer to this account\");\n        \n        require (_from == msg.sender || _operatorApprovals[_from][msg.sender], \"you dont have approval to make this transfer\");\n\n        require(_balances[_id][_from] >0,\"insuffcient balance to transfer from\");\n        _balances[_id][_from] -= _amount;\n        _balances[_id][_to] += _amount;\n\n        emit Events.TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        if(_to.code.length >0){\n        require(IERC1155Receiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data) == IERC1155Receiver.onERC1155BatchReceived.selector, \"Receiver rejected token transfer\");\n        }\n\n    }\n\n\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external{\n        require(_to != address(0), \"The receiving account is an address zero:: cannot transfer to this account\");\n        require(_ids.length == _amounts.length, \"ids and amounts length mismatch\");\n        require (_from == msg.sender || _operatorApprovals[_from][msg.sender], \"you dont have approval to make this transfer\");\n\n        for(uint256 i = 0; i< _ids.length; i++){\n            _balances[_ids[i]][_from] -= _amounts[i];\n            _balances[_ids[i]][_to] += _amounts[i];\n        }\n        emit Events.TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n\n        if(_to.code.length >0){\n        require(IERC1155Receiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data) == IERC1155Receiver.onERC1155BatchReceived.selector, \"Receiver rejected token transfer\");\n        }\n\n    }\n\n    function mint(uint256 _id, uint256 _amount, string memory _uri)  onlyAdmin external {\n\n        if(_id == 0 || _id == 1){\n            require(bytes(_uri).length == 0, \"you cant set URI for this token\");\n\n            _balances[_id][msg.sender] += _amount;\n            totalSupplyOfTokens[_id] = _amount;\n\n        }\n\n       \n         if (_id == 2) {\n            require(bytes(_uri).length > 0, \"you need to pass the URI of this NFT\");\n\n            require(_amount < 2 , \"Batman Nft can only have 1\");\n\n            require(totalSupplyOfTokens[_id] < 1, \"Batman Nft already Exist\");\n\n            _tokenURIs[_id] = _uri;\n            totalSupplyOfTokens[_id] = _amount;\n\n            emit Events.URI(_uri, _id);\n        }\n    }\n\n    function uri(uint256 id) public view returns (string memory) {\n        return _tokenURIs[id]; \n    }\n}\n"
      }
    }
  }
}